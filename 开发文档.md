# 多系统数据对齐 & Agent 编排 Demo 开发文档

**项目名称**: UCAP-agent-demo  
**开发者**: Tom  
**创建时间**: 2025-10-30 22:03:50  
**技术栈**: Python 3.9+, Streamlit, 通义千问API  

## 开发规范

###  分步骤开发原则

> **⚠️ 分步骤开发原则 ⚠️**
> 
> 1. **严格按步骤执行** - 必须完成当前步骤后才能进行下一步
> 2. **不要重复开发** - 开发前请先详细阅读项目内相关内容，遵循原则：能复用就不要重复开发
> 3. **每步必须测试** - 每完成一个开发步骤，立即进行相应测试
> 4. **测试由Tom执行** - 开发者提供详细测试指导（需要给出适合api测试工具的测试数据以及预期结果等），Tom负责实际测试
> 5. **测试通过后继续** - 只有当前步骤测试通过，才能开始下一步开发
> 6. **问题及时修复** - 如测试发现问题，必须先修复再继续
> 7. **代码质量要求** - 对于代码使用方法不明确是，请先调用Context7阅读相关的官方文档，保证知识是最新的
> 8. **代码注释要求** - 所有代码必须包含必要的注释，包括函数、类、方法等
> 
> **📋 每步开发流程：**
> ```
> 开发实现 → 提供测试指导 → Tom执行测试 → 测试通过 → 下一步
>     ↓                                    ↓
> 如有问题 ← 修复问题 ← 测试失败 ← 反馈问题
> ```

###  测试指导原则

> **🔍 测试指导原则**
> 
> 每个开发步骤完成后，开发者必须提供：
> 1. **详细测试步骤** - 具体的测试操作指导
> 2. **预期结果说明** - 明确的成功标准
> 3. **测试数据准备** - 提供测试用的示例数据
> 4. **问题排查指南** - 常见问题的解决方案



## 1. 项目概述

### 1.1 项目目标
构建一个轻量级的"多系统数据对齐 & Agent 编排"Demo，实现：
- 子Agent封装异构系统
- 数据模型对齐（Canonical Model）
- 总控Agent对话式调用
- 统一查询/展示

### 1.2 核心理念
"用假数据把三个系统的差异拉满 → 子Agent内部做'脏活累活'转Canonical → 总控Agent只会说普通话，任何查询都先问子Agent要Canonical数据 → 本地Streamlit面板一起展示。"

### 1.3 技术架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Streamlit UI Layer                       │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   输入框        │  │   JSON展示      │  │   图表展示   │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                 Orchestrator Layer                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Router    │  │  Executor   │  │   LLM Proxy         │  │
│  │  (意图路由)  │  │ (并行执行)   │  │  (通义千问集成)      │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                 Canonical Model Layer                       │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  org | person | customer | transaction (统一数据模型)   │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Agent Layer                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ ERP Agent   │  │  HR Agent   │  │    FIN Agent        │  │
│  │ (JSON文件)   │  │ (SQLite)    │  │    (CSV文件)        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Data Layer                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │erp_orders   │  │   hr.db     │  │   fin_bills.csv     │  │
│  │  .json      │  │ (SQLite)    │  │   (CSV格式)         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 2. 系统设计

### 2.1 三个异构系统设计

| 系统 | 场景 | 数据形态 | 接口风格 | 典型字段差异 | 数据量 |
|------|------|----------|----------|--------------|--------|
| ERP | 销售订单 | JSON文件(本地) | 读文件 | 客户=customer_code, 金额=total_amount, 日期=order_date | 50条 |
| HR | 员工信息 | SQLite单表 | SQL查询 | 人员=emp_id, 部门=dept_name, 入职时间=join_time | 30条 |
| FIN | 财务流水 | CSV文件 | pandas读取 | 对方单位=counter_party, 借贷方向=dr_cr, 时间=tx_timestamp | 40条 |

### 2.2 数据差异化设计

#### ERP系统数据特点：
- 日期格式：`YYYY-MM-DD`
- 金额字段：`total_amount` (数字类型)
- 客户标识：`customer_code` (字符串)
- 币种：混合使用 CNY/USD
- 数据质量：部分记录有空值

#### HR系统数据特点：
- 日期格式：`DD/MM/YYYY`
- 员工标识：`emp_id` (数字类型)
- 部门字段：`dept_name` (中文名称)
- 薪资字段：`salary` (包含货币符号)
- 数据质量：相对整洁

#### FIN系统数据特点：
- 日期格式：`MM-DD-YYYY HH:mm:ss`
- 金额字段：`amount` (字符串，包含货币符号)
- 借贷标识：`dr_cr` (DR/CR标识)
- 对方单位：`counter_party` (可能包含特殊字符)
- 数据质量：存在重复ID、格式不统一

### 2.3 Canonical数据模型

#### 2.3.1 组织表 (org)
```python
class Organization(BaseModel):
    org_id: str          # 格式: {system}_{original_id}
    org_name: str        # 统一组织名称
    org_type: str        # company/dept
    created_at: datetime # ISO格式时间
```

#### 2.3.2 人员表 (person)
```python
class Person(BaseModel):
    person_id: str       # 格式: {system}_{original_id}
    person_name: str     # 统一姓名格式
    org_id: str         # 关联组织ID
    email: str          # 标准邮箱格式
    created_at: datetime # ISO格式时间
```

#### 2.3.3 客户表 (customer)
```python
class Customer(BaseModel):
    customer_id: str     # 格式: {system}_{original_id}
    customer_name: str   # 统一客户名称
    tax_num: str        # 统一税号格式
    created_at: datetime # ISO格式时间
```

#### 2.3.4 交易表 (transaction)
```python
class Transaction(BaseModel):
    tx_id: str           # 格式: {system}_{original_id}
    tx_type: str         # sales/salary/expense
    amount: Decimal      # 统一为Decimal类型
    currency: str        # 统一为CNY
    tx_date: datetime    # ISO格式时间
    customer_id: Optional[str]  # 可选客户ID
    person_id: Optional[str]    # 可选人员ID
    org_id: str         # 关联组织ID
```

## 3. 项目目录结构

```
UCAP-agent-demo/
├── .env.example
├── .gitignore
├── Pydantic指导文档.md
├── README.md
├── agents/                 # Agent 层
│   ├── __init__.py
│   ├── base.py             # 抽象基类，含缓存/过滤/健康检查
│   ├── erp.py              # ERP 系统 Agent
│   ├── fin.py              # 财务系统 Agent
│   └── hr.py               # HR 系统 Agent
├── canonical/              # Canonical 模型层
│   ├── __init__.py
│   ├── mapper.py           # 数据转换与规范化工具
│   └── models.py           # Pydantic 模型定义
├── config/
│   ├── __init__.py
│   └── settings.py         # 应用与数据源配置
├── data/
│   ├── erp_data.json
│   ├── erp_data_generator.py
│   ├── fin_data_generator.py
│   ├── hr_data_generator.py
│   ├── init_database.py
│   └── ucap_demo.db.backup_20251031_111658
├── logs/
├── orchestrator/
│   ├── __init__.py         # 编排层入口，高层 query_across_systems
│   ├── executor.py         # 并发执行、聚合、降级与指标
│   └── router.py           # 系统选择与参数校验
├── requirements.txt
├── tests/
│   ├── __init__.py
│   ├── integration/
│   │   ├── test_canonical_consistency.py   # 一致性与约束
│   │   ├── test_filters_and_cache.py       # 过滤与缓存命中率
│   │   ├── test_error_handling_and_consistency.py  # 错误处理与命名空间一致性
│   │   ├── test_health_and_schema.py       # 健康检查与模式验证
│   │   └── test_orchestrator_router_executor.py    # 编排层路由与执行器集成
│   ├── test_canonical.py
│   ├── test_data_generation.py
│   ├── test_erp_agent.py
│   ├── test_fin_agent.py
│   └── test_hr_agent.py
├── ui/
│   └── __init__.py
└── 开发文档.md
```

## 4. 核心组件设计

### 4.1 BaseAgent抽象类 (agents/base.py)

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from functools import lru_cache
from datetime import datetime, timedelta
from canonical.models import BaseModel

class BaseAgent(ABC):
    def __init__(self, system_name: str):
        self.system_name = system_name
        self.health_status = "healthy"
        self.canonical_version = "v1.0"
        self.cache_ttl = 300  # 5分钟缓存
    
    @abstractmethod
    def pull_raw(self) -> List[Dict[str, Any]]:
        """拉取原始数据"""
        pass
    
    @abstractmethod
    def map_to_canonical(self, raw_data: List[Dict]) -> List[BaseModel]:
        """映射到标准模型"""
        pass
    
    @lru_cache(maxsize=128)
    def query_canonical(self, filter_params: Optional[Dict] = None) -> List[BaseModel]:
        """查询标准化数据（带缓存）"""
        raw_data = self.pull_raw()
        canonical_data = self.map_to_canonical(raw_data)
        
        if filter_params:
            # 应用过滤条件
            canonical_data = self._apply_filters(canonical_data, filter_params)
        
        return canonical_data
    
    def tools(self) -> Dict[str, Any]:
        """返回Agent工具定义"""
        return {
            "name": f"{self.system_name}_query",
            "description": f"查询{self.system_name}系统数据",
            "function": self.query_canonical
        }
    
    def _apply_filters(self, data: List[BaseModel], filters: Dict) -> List[BaseModel]:
        """应用过滤条件"""
        # 实现过滤逻辑
        pass
```

### 4.2 数据转换工具 (canonical/mapper.py)

```python
from datetime import datetime
from decimal import Decimal
import re
from typing import Any, Optional

class DataMapper:
    @staticmethod
    def normalize_date(date_str: str, source_format: str = None) -> datetime:
        """标准化日期格式"""
        # 支持多种日期格式转换为ISO格式
        pass
    
    @staticmethod
    def normalize_amount(amount: Any) -> Decimal:
        """标准化金额格式"""
        # 处理不同的金额格式，统一转换为Decimal
        pass
    
    @staticmethod
    def normalize_id(original_id: Any, system_prefix: str) -> str:
        """标准化ID格式"""
        return f"{system_prefix}_{str(original_id)}"
    
    @staticmethod
    def normalize_currency(currency: str) -> str:
        """标准化货币代码"""
        # 统一转换为CNY
        currency_map = {
            "USD": "CNY",  # 假设汇率转换
            "RMB": "CNY",
            "人民币": "CNY"
        }
        return currency_map.get(currency.upper(), "CNY")
```

### 4.3 意图路由器 (orchestrator/router.py)

```python
class IntentRouter:
    def __init__(self):
        self.keyword_mapping = {
            "销售": ["erp"],
            "订单": ["erp"],
            "客户": ["erp"],
            "员工": ["hr"],
            "人员": ["hr"],
            "部门": ["hr"],
            "薪资": ["hr"],
            "财务": ["fin"],
            "支出": ["fin"],
            "流水": ["fin"],
            "报销": ["fin"]
        }
    
    def route(self, query: str) -> List[str]:
        """根据查询意图路由到相应的Agent"""
        agents = set()
        for keyword, agent_list in self.keyword_mapping.items():
            if keyword in query:
                agents.update(agent_list)
        
        # 如果没有匹配到关键词，返回所有Agent
        if not agents:
            agents = {"erp", "hr", "fin"}
        
        return list(agents)
```

### 4.4 通义千问集成 (orchestrator/llm_proxy.py)

```python
import json
from typing import Dict, List, Any
import requests

class QianwenProxy:
    def __init__(self, api_key: str, model: str = "qwen-turbo"):
        self.api_key = api_key
        self.model = model
        self.base_url = "https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation"
    
    def generate_response(self, query: str, tools: List[Dict], context: Dict = None) -> Dict:
        """生成响应，支持工具调用"""
        messages = [
            {
                "role": "system",
                "content": "你是一个企业数据查询助手，可以调用不同系统的Agent获取数据。"
            },
            {
                "role": "user", 
                "content": query
            }
        ]
        
        payload = {
            "model": self.model,
            "input": {
                "messages": messages
            },
            "parameters": {
                "tools": tools,
                "result_format": "message"
            }
        }
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        response = requests.post(self.base_url, headers=headers, json=payload)
        return response.json()
```

## 5. 开发计划

### 5.1 第一阶段：基础框架搭建 (预计2天)

#### 步骤1：环境准备和项目初始化
- [x] 创建项目目录结构
- [x] 配置Python虚拟环境
- [x] 安装基础依赖包
- [ ] 配置通义千问API密钥

#### 步骤2：数据层开发
- [x] 编写数据生成脚本 (data_generator.py)
- [x] 生成三个系统的差异化假数据
- [x] 验证数据格式和差异性

#### 步骤3：Canonical模型定义
- [x] 实现Pydantic数据模型 (canonical/models.py)
- [x] 实现数据转换工具 (canonical/mapper.py)
- [x] 编写单元测试验证模型正确性
- [x] 修复Pydantic v2兼容性问题

### 5.2 第二阶段：Agent层开发 (预计3天)

#### 步骤4：BaseAgent抽象类
- [x] 实现BaseAgent基类 (agents/base.py)
- [x] 添加缓存机制和错误处理
- [ ] 编写基类单元测试

#### 步骤5：具体Agent实现
- [x] 实现ERPAgent (agents/erp.py)
- [x] 实现HRAgent (agents/hr.py)  
- [x] 实现FINAgent (agents/fin.py)
- [x] 每个Agent完成后立即进行单元测试

#### 步骤6：Agent集成测试
- [x] 测试数据映射正确性（已完成：`tests/integration/test_canonical_consistency.py`）
- [x] 测试缓存机制（已完成：`tests/integration/test_filters_and_cache.py`）
- [x] 测试错误处理（已完成：`tests/integration/test_error_handling_and_consistency.py`）

### 5.3 第三阶段：编排层开发 (预计2天)

#### 步骤7：路由和执行器
- [x] 实现IntentRouter (orchestrator/router.py)
- [x] 实现并行执行器 (orchestrator/executor.py)
- [ ] 集成通义千问API (orchestrator/llm_proxy.py)
- [x] 暴露高层入口 query_across_systems (orchestrator/__init__.py)

#### 步骤8：编排层测试
- [x] 测试意图路由准确性（覆盖 systems 子集与默认路由）
- [x] 测试并行执行与降级（部分失败、超时、去重与过滤透传）
- [ ] 测试LLM集成

### 5.4 第四阶段：UI层开发 (预计1天)

#### 步骤9：Streamlit界面
- [ ] 实现基础UI布局 (ui/streamlit_app.py)
- [ ] 集成查询功能
- [ ] 添加JSON和图表展示

#### 步骤10：端到端测试
- [ ] 完整流程测试
- [ ] 性能优化
- [ ] 用户体验优化

### 5.5 第五阶段：Docker化和文档 (预计1天)

#### 步骤11：容器化部署
- [ ] 编写Dockerfile
- [ ] 配置docker-compose.yml
- [ ] 测试容器化部署

#### 步骤12：文档和演示
- [ ] 完善README.md
- [ ] 录制演示视频
- [ ] 项目交付

## 6. 测试策略

### 6.1 单元测试
- **覆盖范围**: 每个Agent的map_to_canonical()方法
- **测试数据**: 提供样本输入和期望输出的JSON文件
- **自动化**: 使用pytest框架，CI自动执行

### 6.2 集成测试
- **Agent集成**: 测试Agent之间的数据一致性
- **编排层测试**: 测试路由和执行的正确性
- **端到端测试**: 完整用户场景测试

### 6.3 性能测试
- **响应时间**: 查询响应时间 < 100ms
- **并发处理**: 支持多用户同时查询
- **缓存效果**: 验证缓存命中率

### 6.4 测试原则
- 每个开发步骤完成后立即测试
- 保留核心单元测试，删除临时测试代码
- 测试代码删除前需要Tom确认

## 7. Docker化部署

### 7.1 Dockerfile设计
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8501

CMD ["streamlit", "run", "ui/streamlit_app.py", "--server.port=8501", "--server.address=0.0.0.0"]
```

### 7.2 docker-compose.yml
```yaml
version: '3.8'
services:
  ucap-agent-demo:
    build: .
    ports:
      - "8501:8501"
    environment:
      - QIANWEN_API_KEY=${QIANWEN_API_KEY}
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
```

### 7.3 部署说明
- 支持一键启动: `docker-compose up`
- 数据持久化: 数据和日志目录映射到宿主机
- 环境变量: API密钥通过环境变量配置

## 8. 配置管理

### 8.1 应用配置 (config/settings.py)
```python
import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    # API配置
    qianwen_api_key: str = os.getenv("QIANWEN_API_KEY", "")
    qianwen_model: str = "qwen-turbo"
    
    # 缓存配置
    cache_ttl: int = 300
    cache_maxsize: int = 128
    
    # 数据配置
    data_dir: str = "data"
    log_dir: str = "logs"
    
    # UI配置
    streamlit_port: int = 8501
    
    class Config:
        env_file = ".env"

settings = Settings()
```

## 9. 风险控制和注意事项

### 9.1 已知风险点
| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 假数据过于整齐 | 失去差异化效果 | 人为加入空值、格式不一致、重复ID |
| LLM响应不稳定 | 查询结果不准确 | 强制工具调用模式，添加结果验证 |
| 并发读写冲突 | 数据不一致 | 使用文件锁，单例模式 |
| API配额限制 | 服务不可用 | 添加重试机制，降级到FakeLLM |

### 9.2 开发注意事项
- 严格按照分步开发原则，每步完成后测试
- 复用项目中已有代码，避免重复开发
- 保持代码整洁，使用适当的设计模式
- 及时更新文档，记录重要决策

### 9.3 扩展预留
- 预留更多数据源接入接口
- 预留权限管理模块
- 预留监控和日志分析功能
- 预留分布式部署能力

## 10. 交付标准

### 10.1 功能完整性
- [ ] 三个Agent正常工作，数据映射正确
- [ ] 编排层能够正确路由和执行查询
- [ ] UI界面友好，支持查询和结果展示
- [ ] Docker化部署成功

### 10.2 代码质量
- [ ] 单元测试覆盖率 > 80%
- [ ] 代码符合PEP8规范
- [ ] 关键功能有详细注释
- [ ] 错误处理完善

### 10.3 文档完整性
- [ ] README.md包含安装和使用说明
- [ ] API文档清晰
- [ ] 架构图和流程图完整
- [ ] 演示视频录制完成

## 11. 开发进度记录

### 11.1 详细进度记录

**2025-11-10T17:00:29+08:00 (Asia/Shanghai)**
- ✅ 完成编排层高层入口：`orchestrator/__init__.py` 暴露 `query_across_systems(filter_params, systems=None, timeout_ms=...)`
- ✅ 完成执行器模块：`orchestrator/executor.py`（并发执行、聚合、错误降级、指标统计），复用 `BaseAgent.query_canonical` 与缓存
- ✅ 完成路由器模块：`orchestrator/router.py`（系统选择与参数校验）
- ✅ 新增并完善编排层集成测试：`tests/integration/test_orchestrator_router_executor.py`（路由子集、部分失败、超时、过滤透传、去重）
- ♻️ 复用：严格复用现有 Agent 方法与 Canonical 模型，无重复开发
- 📈 指标：记录每系统执行时长与结果计数、成功/失败统计、总时长
- 📚 说明：详细断言与场景请参见测试文件；按需继续补充性能与LLM集成测试
- ▶️ 下一步：开展 LLM 代理集成与性能测试

#### 📋 当前进度：第三阶段进行中，路由与执行器完成
- **当前任务**: 文档更新与进度同步（目录结构、开发计划标记）
- **下一步**: 集成 LLM 代理与相关测试

#### 📝 开发日志

**2025-11-07 23:30:37**
- ✅ 新增并通过集成测试：`tests/integration/test_canonical_consistency.py`、`tests/integration/test_filters_and_cache.py`、`tests/integration/test_error_handling_and_consistency.py`
- ♻️ 复用：`BaseAgent.query_canonical/clear_cache/get_cache_info` 与 `DataMapper` 方法，无重复开发
- 🔧 修订：HR 交易金额断言调整为 `>= 0`，ERP/FIN 保持 `> 0`
- 🧩 一致性：ID 命名空间统一（`erp_/hr_/fin_`），FIN 在缺失组织时采用回退前缀保障一致性
- 📈 缓存：重复调用命中率提升、参数变化触发未命中，命中率指标可通过 `get_cache_info()` 获取
- 📚 说明：详细断言与测试运行说明，请参考各测试文件头部注释
- ▶️ 下一步：开始实现编排层（IntentRouter/Executor/LLM 代理）
- ✅ 完成 FINAgent 开发与映射（`agents/fin.py`）
- ✅ 新增测试 `tests/test_fin_agent.py` 并通过
- 🔧 修复：交易 `currency` 统一设为 `CNY`，满足 Canonical 校验
- ♻️ 复用：沿用 `BaseAgent` 与 `DataMapper`，避免重复开发
- 🗂 架构说明修订：FIN 数据源为 SQLite（`ucap_demo.db` 的 `fin_*` 表），与 ERP/HR 一致
- 📚 技术要点：
  - 统一 `_entity` 标签，集中索引支持跨表关联（`org_code_to_id`）
  - `amount` 使用 `normalize_amount` 转 `Decimal`（两位小数）
  - 日期统一 `normalize_date('fin')`；`created_at` 采用回退链路
  - 组织/人员/客户/交易字段映射与 Pydantic v2 校验一致
- 🧪 测试与保留：`tests/test_fin_agent.py` 暂时保留，删除需由 Tom 确认

**2025-11-03 12:18:13**
- ✅ 完成Pydantic v2兼容性修复
- ✅ 修复所有测试用例的字段名映射问题
- ✅ 优化DataMapper.normalize_amount方法的错误处理
- ✅ 所有19个核心测试全部通过
- 📚 **技术要点**：
  - Pydantic v2字段名必须与模型定义严格一致
  - 测试数据中的`canonical_id`需要根据不同模型使用对应字段名
  - `system_type` → `source_system`，`created_time` → `created_at`
  - DataMapper方法需要正确处理无效输入并抛出适当异常

**2025-10-31 **
- ✅ 完成项目基础框架搭建
- ✅ 实现三个系统的数据生成器 (ERP/HR/FIN)
- ✅ 完成Pydantic数据模型定义
- ✅ 实现DataMapper数据转换工具
- ✅ 编写完整的单元测试套件

**2025-10-30 22:03:50**
- ✅ 完成开发文档初版编写
- ✅ 添加开发进度记录部分
- ✅ 等待Tom审核确认


**文档版本**: v1.5  
**最后更新**: 2025-11-10T17:00:29+08:00 (Asia/Shanghai)  
**审核状态**: 第三阶段编排层开发进行中（LLM代理待集成）