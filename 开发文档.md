# 多系统数据对齐 & Agent 编排 Demo 开发文档

**项目名称**: UCAP-agent-demo  
**开发者**: Tom  
**创建时间**: 2025-10-30 22:03:50  
**技术栈**: Python 3.9+, Streamlit, 通义千问API  

## 开发规范

###  分步骤开发原则

> **⚠️ 分步骤开发原则 ⚠️**
> 
> 1. **严格按步骤执行** - 必须完成当前步骤后才能进行下一步
> 2. **不要重复开发** - 开发前请先详细阅读项目内相关内容，遵循原则：能复用就不要重复开发
> 3. **每步必须测试** - 每完成一个开发步骤，立即进行相应测试
> 4. **测试由Tom执行** - 开发者提供详细测试指导（需要给出适合api测试工具的测试数据以及预期结果等），Tom负责实际测试
> 5. **测试通过后继续** - 只有当前步骤测试通过，才能开始下一步开发
> 6. **问题及时修复** - 如测试发现问题，必须先修复再继续
> 7. **代码质量要求** - 对于代码使用方法不明确是，请先调用Context7阅读相关的官方文档，保证知识是最新的
> 8. **代码注释要求** - 所有代码必须包含必要的注释，包括函数、类、方法等
> 
> **📋 每步开发流程：**
> ```
> 开发实现 → 提供测试指导 → Tom执行测试 → 测试通过 → 下一步
>     ↓                                    ↓
> 如有问题 ← 修复问题 ← 测试失败 ← 反馈问题
> ```

###  测试指导原则

> **🔍 测试指导原则**
> 
> 每个开发步骤完成后，开发者必须提供：
> 1. **详细测试步骤** - 具体的测试操作指导
> 2. **预期结果说明** - 明确的成功标准
> 3. **测试数据准备** - 提供测试用的示例数据
> 4. **问题排查指南** - 常见问题的解决方案



## 1. 项目概述

### 1.1 项目目标
构建一个轻量级的"多系统数据对齐 & Agent 编排"Demo，实现：
- 子Agent封装异构系统
- 数据模型对齐（Canonical Model）
- 总控Agent对话式调用
- 统一查询/展示

### 1.2 核心理念
"用假数据把三个系统的差异拉满 → 子Agent内部做'脏活累活'转Canonical → 总控Agent只会说普通话，任何查询都先问子Agent要Canonical数据 → 本地Streamlit面板一起展示。"

### 1.3 技术架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Streamlit UI Layer                       │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   输入框        │  │   JSON展示      │  │   图表展示   │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                 Orchestrator Layer                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Router    │  │  Executor   │  │   LLM Proxy         │  │
│  │  (意图路由)  │  │ (并行执行)   │  │  (通义千问集成)      │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                 Canonical Model Layer                       │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  org | person | customer | transaction (统一数据模型)   │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Agent Layer                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ ERP Agent   │  │  HR Agent   │  │    FIN Agent        │  │
│  │ (JSON文件)   │  │ (SQLite)    │  │    (CSV文件)        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Data Layer                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │erp_orders   │  │   hr.db     │  │   fin_bills.csv     │  │
│  │  .json      │  │ (SQLite)    │  │   (CSV格式)         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 2. 系统设计

### 2.1 三个异构系统设计

| 系统 | 场景 | 数据形态 | 接口风格 | 典型字段差异 | 数据量 |
|------|------|----------|----------|--------------|--------|
| ERP | 销售订单 | JSON文件(本地) | 读文件 | 客户=customer_code, 金额=total_amount, 日期=order_date | 50条 |
| HR | 员工信息 | SQLite单表 | SQL查询 | 人员=emp_id, 部门=dept_name, 入职时间=join_time | 30条 |
| FIN | 财务流水 | CSV文件 | pandas读取 | 对方单位=counter_party, 借贷方向=dr_cr, 时间=tx_timestamp | 40条 |

### 2.2 数据差异化设计

#### ERP系统数据特点：
- 日期格式：`YYYY-MM-DD`
- 金额字段：`total_amount` (数字类型)
- 客户标识：`customer_code` (字符串)
- 币种：混合使用 CNY/USD
- 数据质量：部分记录有空值

#### HR系统数据特点：
- 日期格式：`DD/MM/YYYY`
- 员工标识：`emp_id` (数字类型)
- 部门字段：`dept_name` (中文名称)
- 薪资字段：`salary` (包含货币符号)
- 数据质量：相对整洁

#### FIN系统数据特点：
- 日期格式：`MM-DD-YYYY HH:mm:ss`
- 金额字段：`amount` (字符串，包含货币符号)
- 借贷标识：`dr_cr` (DR/CR标识)
- 对方单位：`counter_party` (可能包含特殊字符)
- 数据质量：存在重复ID、格式不统一

### 2.3 Canonical数据模型

#### 2.3.1 组织表 (org)
```python
class Organization(BaseModel):
    org_id: str          # 格式: {system}_{original_id}
    org_name: str        # 统一组织名称
    org_type: str        # company/dept
    created_at: datetime # ISO格式时间
```

#### 2.3.2 人员表 (person)
```python
class Person(BaseModel):
    person_id: str       # 格式: {system}_{original_id}
    person_name: str     # 统一姓名格式
    org_id: str         # 关联组织ID
    email: str          # 标准邮箱格式
    created_at: datetime # ISO格式时间
```

#### 2.3.3 客户表 (customer)
```python
class Customer(BaseModel):
    customer_id: str     # 格式: {system}_{original_id}
    customer_name: str   # 统一客户名称
    tax_num: str        # 统一税号格式
    created_at: datetime # ISO格式时间
```

#### 2.3.4 交易表 (transaction)
```python
class Transaction(BaseModel):
    tx_id: str           # 格式: {system}_{original_id}
    tx_type: str         # sales/salary/expense
    amount: Decimal      # 统一为Decimal类型
    currency: str        # 统一为CNY
    tx_date: datetime    # ISO格式时间
    customer_id: Optional[str]  # 可选客户ID
    person_id: Optional[str]    # 可选人员ID
    org_id: str         # 关联组织ID
```

## 3. 项目目录结构

```
UCAP-agent-demo/
├── .env.example
├── .gitignore
├── Pydantic指导文档.md
├── README.md
├── agents/                 # Agent 层
│   ├── __init__.py
│   ├── base.py             # 抽象基类，含缓存/过滤/健康检查
│   ├── erp.py              # ERP 系统 Agent
│   ├── fin.py              # 财务系统 Agent
│   └── hr.py               # HR 系统 Agent
├── canonical/              # Canonical 模型层
│   ├── __init__.py
│   ├── mapper.py           # 数据转换与规范化工具
│   └── models.py           # Pydantic 模型定义
├── config/
│   ├── __init__.py
│   └── settings.py         # 应用与数据源配置
├── data/
│   ├── erp_data.json
│   ├── erp_data_generator.py
│   ├── fin_data_generator.py
│   ├── hr_data_generator.py
│   ├── init_database.py
│   └── ucap_demo.db.backup_20251031_111658
├── logs/
├── orchestrator/
│   ├── __init__.py         # 编排层入口，高层 query_across_systems / nl_query
│   ├── executor.py         # 并发执行、聚合、降级与指标
│   ├── router.py           # 系统选择与参数校验
│   └── llm_proxy.py        # LLM 代理（通义千问），解析自然语言为工具参数
├── api/                    # FastAPI 方案A
│   ├── __init__.py
│   ├── main.py             # FastAPI 应用入口与路由
│   └── schemas.py          # 请求/响应 Pydantic 模型
├── requirements.txt
├── tests/
│   ├── __init__.py
│   ├── integration/
│   │   ├── test_canonical_consistency.py   # 一致性与约束
│   │   ├── test_filters_and_cache.py       # 过滤与缓存命中率
│   │   ├── test_error_handling_and_consistency.py  # 错误处理与命名空间一致性
│   │   ├── test_health_and_schema.py       # 健康检查与模式验证
│   │   ├── test_orchestrator_router_executor.py    # 编排层路由与执行器集成
│   │   └── test_nl_query_llm_proxy.py              # LLM 代理与 nl_query 集成
│   ├── test_canonical.py
│   ├── test_data_generation.py
│   ├── test_erp_agent.py
│   ├── test_fin_agent.py
│   └── test_hr_agent.py
│   └── api/
│       └── test_api_endpoints.py           # 接口级测试（方案A端点）
├── ui/
│   ├── __init__.py
│   └── nl_query.py         # Streamlit 自然语言查询入口（方案B）
└── 开发文档.md
```

## 4. 核心组件设计

### 4.1 BaseAgent抽象类 (agents/base.py)

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from functools import lru_cache
from datetime import datetime, timedelta
from canonical.models import BaseModel

class BaseAgent(ABC):
    def __init__(self, system_name: str):
        self.system_name = system_name
        self.health_status = "healthy"
        self.canonical_version = "v1.0"
        self.cache_ttl = 300  # 5分钟缓存
    
    @abstractmethod
    def pull_raw(self) -> List[Dict[str, Any]]:
        """拉取原始数据"""
        pass
    
    @abstractmethod
    def map_to_canonical(self, raw_data: List[Dict]) -> List[BaseModel]:
        """映射到标准模型"""
        pass
    
    @lru_cache(maxsize=128)
    def query_canonical(self, filter_params: Optional[Dict] = None) -> List[BaseModel]:
        """查询标准化数据（带缓存）"""
        raw_data = self.pull_raw()
        canonical_data = self.map_to_canonical(raw_data)
        
        if filter_params:
            # 应用过滤条件
            canonical_data = self._apply_filters(canonical_data, filter_params)
        
        return canonical_data
    
    def tools(self) -> Dict[str, Any]:
        """返回Agent工具定义"""
        return {
            "name": f"{self.system_name}_query",
            "description": f"查询{self.system_name}系统数据",
            "function": self.query_canonical
        }
    
    def _apply_filters(self, data: List[BaseModel], filters: Dict) -> List[BaseModel]:
        """应用过滤条件"""
        # 实现过滤逻辑
        pass
```

### 4.2 数据转换工具 (canonical/mapper.py)

```python
from datetime import datetime
from decimal import Decimal
import re
from typing import Any, Optional

class DataMapper:
    @staticmethod
    def normalize_date(date_str: str, source_format: str = None) -> datetime:
        """标准化日期格式"""
        # 支持多种日期格式转换为ISO格式
        pass
    
    @staticmethod
    def normalize_amount(amount: Any) -> Decimal:
        """标准化金额格式"""
        # 处理不同的金额格式，统一转换为Decimal
        pass
    
    @staticmethod
    def normalize_id(original_id: Any, system_prefix: str) -> str:
        """标准化ID格式"""
        return f"{system_prefix}_{str(original_id)}"
    
    @staticmethod
    def normalize_currency(currency: str) -> str:
        """标准化货币代码"""
        # 统一转换为CNY
        currency_map = {
            "USD": "CNY",  # 假设汇率转换
            "RMB": "CNY",
            "人民币": "CNY"
        }
        return currency_map.get(currency.upper(), "CNY")
```

### 4.3 意图路由器 (orchestrator/router.py)

```python
class IntentRouter:
    def __init__(self):
        self.keyword_mapping = {
            "销售": ["erp"],
            "订单": ["erp"],
            "客户": ["erp"],
            "员工": ["hr"],
            "人员": ["hr"],
            "部门": ["hr"],
            "薪资": ["hr"],
            "财务": ["fin"],
            "支出": ["fin"],
            "流水": ["fin"],
            "报销": ["fin"]
        }
    
    def route(self, query: str) -> List[str]:
        """根据查询意图路由到相应的Agent"""
        agents = set()
        for keyword, agent_list in self.keyword_mapping.items():
            if keyword in query:
                agents.update(agent_list)
        
        # 如果没有匹配到关键词，返回所有Agent
        if not agents:
            agents = {"erp", "hr", "fin"}
        
        return list(agents)
```

### 4.4 通义千问集成 (orchestrator/llm_proxy.py)

```python
import json
from typing import Dict, List, Any
import requests

class QianwenProxy:
    def __init__(self, api_key: str, model: str = "qwen-turbo"):
        self.api_key = api_key
        self.model = model
        self.base_url = "https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation"
    
    def generate_response(self, query: str, tools: List[Dict], context: Dict = None) -> Dict:
        """生成响应，支持工具调用"""
        messages = [
            {
                "role": "system",
                "content": "你是一个企业数据查询助手，可以调用不同系统的Agent获取数据。"
            },
            {
                "role": "user", 
                "content": query
            }
        ]
        
        payload = {
            "model": self.model,
            "input": {
                "messages": messages
            },
            "parameters": {
                "tools": tools,
                "result_format": "message"
            }
        }
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        response = requests.post(self.base_url, headers=headers, json=payload)
        return response.json()
```

## 5. 开发计划

### 5.1 第一阶段：基础框架搭建 (预计2天)

#### 步骤1：环境准备和项目初始化
- [x] 创建项目目录结构
- [x] 配置Python虚拟环境
- [x] 安装基础依赖包
- [x] 配置通义千问API密钥

#### 步骤2：数据层开发
- [x] 编写数据生成脚本 (data_generator.py)
- [x] 生成三个系统的差异化假数据
- [x] 验证数据格式和差异性

#### 步骤3：Canonical模型定义
- [x] 实现Pydantic数据模型 (canonical/models.py)
- [x] 实现数据转换工具 (canonical/mapper.py)
- [x] 编写单元测试验证模型正确性
- [x] 修复Pydantic v2兼容性问题

### 5.2 第二阶段：Agent层开发 (预计3天)

#### 步骤4：BaseAgent抽象类
- [x] 实现BaseAgent基类 (agents/base.py)
- [x] 添加缓存机制和错误处理
- [x] 编写基类单元测试

#### 步骤5：具体Agent实现
- [x] 实现ERPAgent (agents/erp.py)
- [x] 实现HRAgent (agents/hr.py)  
- [x] 实现FINAgent (agents/fin.py)
- [x] 每个Agent完成后立即进行单元测试

#### 步骤6：Agent集成测试
- [x] 测试数据映射正确性（已完成：`tests/integration/test_canonical_consistency.py`）
- [x] 测试缓存机制（已完成：`tests/integration/test_filters_and_cache.py`）
- [x] 测试错误处理（已完成：`tests/integration/test_error_handling_and_consistency.py`）

### 5.3 第三阶段：编排层开发 (预计2天)

#### 步骤7：路由和执行器
- [x] 实现IntentRouter (orchestrator/router.py)
- [x] 实现并行执行器 (orchestrator/executor.py)
- [x] 集成通义千问API (orchestrator/llm_proxy.py)
- [x] 暴露高层入口 query_across系统 & nl_query (orchestrator/__init__.py)

#### 步骤8：编排层测试
- [x] 测试意图路由准确性（覆盖 systems 子集与默认路由）
- [x] 测试并行执行与降级（部分失败、超时、去重与过滤透传）
- [x] 测试LLM集成（新增 `tests/integration/test_nl_query_llm_proxy.py`）

### 5.4 第四阶段：UI层开发 (预计1天)

#### 步骤9：Streamlit界面（方案B优先）
- [x] 实现基础UI布局 (ui/nl_query.py)
- [x] 集成自然语言查询入口（调用 orchestrator.nl_query 并展示结果）
- [x] 添加图表展示（优先补齐；FastAPI 方案A已完成见下）
  - 系统结果计数柱状图：展示 `organizations/persons/customers/transactions` 的数量
  - 交易金额分布直方图：基于 `transactions.amount` 的区间分布
  - 交易金额时间序列折线：按 `tx_date`（日）聚合总额或数量
  - LLM 指标概览：`metrics.llm` 的延迟折线与使用/降级占比饼图

#### 步骤9B：FastAPI端点（方案A）
- [x] 创建 FastAPI 应用骨架与路由模块 (api/main.py)
- [x] 定义请求/响应 Pydantic 模型 (api/schemas.py)
- [x] 实现 `POST /nl-query` 与 `POST /query` 桥接编排层入口 (orchestrator/__init__.py)
- [x] 统一错误处理与响应结构（422/400 返回统一结构，附 `metrics.api`）
- [x] 集成端点级指标：`metrics.api.duration_ms/timeout_ms/systems/entity_type/limit`
- [x] 新增接口级测试 (tests/api/test_api_endpoints.py)
- [x] 依赖补充：requirements.txt 增加 `httpx`

#### 步骤10：端到端测试
- [ ] 完整流程测试
- [ ] 性能优化
- [ ] 用户体验优化

### 5.5 第五阶段：Docker化和文档 (预计1天)

#### 步骤11：容器化部署
- [ ] 编写Dockerfile
- [ ] 配置docker-compose.yml
- [ ] 测试容器化部署

#### 步骤12：文档和演示
- [ ] 完善README.md
- [ ] 录制演示视频
- [ ] 项目交付

### 5.6 第六阶段：缓存与队列集成（后续）

- [ ] 设计 Redis 接入方案（用于缓存/队列），与现有 BaseAgent 缓存策略保持一致与不冲突
- [ ] 配置管理与环境变量约定（`REDIS_URL` 等），在 `.env` 与文档中补充
- [ ] 评审与对齐后再实施接入与集成测试（当前阶段不开发）

### 5.7 时间过滤增强计划
- [x] Prompt优化与结构化约束 (orchestrator/llm_proxy.py)
  - 说明：强化必须输出 `date_from`/`date_to` 的规则与 JSON 结构。
- [x] 小型LLM窄域补齐 (orchestrator/llm_proxy.py)
  - 说明：主/降级路径缺失时间时，触发窄域提取仅返回 `date_from`/`date_to`。
  - 配置：`ENABLE_TIME_ENHANCEMENTS`、`ENABLE_NARROW_TIME_LLM`。
- [x] 时间归一化与相对/固定时间解析 (orchestrator/llm_proxy.py)
  - 说明：统一解析“本周/上月/去年/近N天/近N周/近N月/本季度”等中文时间表达并归一为 ISO8601。
  - 配置：受 `ENABLE_TIME_ENHANCEMENTS` 总开关控制。
- [x] 降级解析扩展（字典与正则） (orchestrator/llm_proxy.py)
  - 说明：补充更多中文表达与边界（含“个”的数词用法），仅在缺失时补齐。
- [x] 可观测性与开关（运维保障） (config/settings.py, orchestrator/llm_proxy.py)
  - 开关与环境变量（精简）：
    - `ENABLE_TIME_ENHANCEMENTS`（默认 `true`）：总开关；关闭后禁用“时间锚定纠偏”和“窄域时间提取”，保留降级“缺失时补齐”。
    - `ENABLE_NARROW_TIME_LLM`（默认 `true`）：仅控制“窄域时间提取”；当总开关为 `false` 时不生效。
  - 快速禁用：在 `.env` 设 `ENABLE_TIME_ENHANCEMENTS=false` 即可一键回滚增强路径。
  - 指标：`time_anchor_override_used`、`time_anchor_latency_ms`、`time_narrow_used`、`time_narrow_latency_ms`。

## 6. 测试策略

### 6.1 单元测试
- **覆盖范围**: 每个Agent的map_to_canonical()方法
- **测试数据**: 提供样本输入和期望输出的JSON文件
- **自动化**: 使用pytest框架，CI自动执行

### 6.2 集成测试
- **Agent集成**: 测试Agent之间的数据一致性
- **编排层测试**: 测试路由和执行的正确性
- **端到端测试**: 完整用户场景测试

### 6.3 性能测试
- **响应时间**: 查询响应时间 < 100ms
- **并发处理**: 支持多用户同时查询
- **缓存效果**: 验证缓存命中率

### 6.4 测试原则
- 每个开发步骤完成后立即测试
- 保留核心单元测试，删除临时测试代码
- 测试代码删除前需要Tom确认

## 7. Docker化部署

### 7.1 Dockerfile设计
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8501

CMD ["streamlit", "run", "ui/streamlit_app.py", "--server.port=8501", "--server.address=0.0.0.0"]
```

### 7.2 docker-compose.yml
```yaml
version: '3.8'
services:
  ucap-agent-demo:
    build: .
    ports:
      - "8501:8501"
    environment:
      - DASHSCOPE_API_KEY=${DASHSCOPE_API_KEY}
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
```

### 7.3 部署说明
- 支持一键启动: `docker-compose up`
- 数据持久化: 数据和日志目录映射到宿主机
- 环境变量: API密钥通过环境变量配置

## 8. 配置管理

### 8.1 应用配置 (config/settings.py)
```python
from typing import Optional
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    # LLM 配置（DashScope/Qwen）
    dashscope_api_key: Optional[str] = Field(default=None, alias="DASHSCOPE_API_KEY")
    default_model: str = Field(default="qwen-max", alias="DEFAULT_MODEL")
    max_tokens: int = Field(default=1024, alias="MAX_TOKENS")
    temperature: float = Field(default=0.3, alias="TEMPERATURE")

    # 缓存配置
    cache_ttl_seconds: int = Field(default=300, alias="CACHE_TTL_SECONDS")
    cache_maxsize: int = Field(default=128, alias="CACHE_MAXSIZE")

    # 数据与UI配置
    data_dir: str = Field(default="data", alias="DATA_DIR")
    log_dir: str = Field(default="logs", alias="LOG_DIR")
    ui_port: int = Field(default=8501, alias="UI_PORT")

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
        populate_by_name=True,
    )

settings = Settings()
```
说明：文档与配置已统一为 `DASHSCOPE_API_KEY` / `DEFAULT_MODEL` 等键。`.env.example` 保持不变。

## 9. 风险控制和注意事项

### 9.1 已知风险点
| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 假数据过于整齐 | 失去差异化效果 | 人为加入空值、格式不一致、重复ID |
| LLM响应不稳定 | 查询结果不准确 | 强制工具调用模式，添加结果验证 |
| 并发读写冲突 | 数据不一致 | 使用文件锁，单例模式 |
| API配额限制 | 服务不可用 | 添加重试机制，降级到FakeLLM |

### 9.2 开发注意事项
- 严格按照分步开发原则，每步完成后测试
- 复用项目中已有代码，避免重复开发
- 保持代码整洁，使用适当的设计模式
- 及时更新文档，记录重要决策

### 9.3 扩展预留
- 预留更多数据源接入接口
- 预留权限管理模块
- 预留监控和日志分析功能
- 预留分布式部署能力

## 10. 交付标准

### 10.1 功能完整性
- [ ] 三个Agent正常工作，数据映射正确
- [ ] 编排层能够正确路由和执行查询
- [ ] UI界面友好，支持查询和结果展示
- [ ] Docker化部署成功

### 10.2 代码质量
- [ ] 单元测试覆盖率 > 80%
- [ ] 代码符合PEP8规范
- [ ] 关键功能有详细注释
- [ ] 错误处理完善

### 10.3 文档完整性
- [ ] README.md包含安装和使用说明
- [ ] API文档清晰
- [ ] 架构图和流程图完整
- [ ] 演示视频录制完成

## 11. 开发进度记录

### 11.1 详细进度记录
**2025-11-18T11:39:00+08:00 (Asia/Shanghai)**
- ✅ 方案A（FastAPI端点）完成：`api/main.py` 暴露 `POST /nl-query` 与 `POST /query`，桥接 `orchestrator.nl_query` 与 `query_across_systems`
- ✅ 请求/响应模型：`api/schemas.py` 定义 `FilterParams/NLQueryRequest/QueryRequest/QueryResponse`
- ✅ 统一错误处理：422/400 统一结构，包含 `warnings/errors/metrics`；端点异常处理与指标注入详见 `api/main.py`
- ✅ 指标注入：端点层记录 `metrics.api.duration_ms/timeout_ms/systems/entity_type/limit`，与编排层指标合并
- ✅ 接口级测试：`tests/api/test_api_endpoints.py` 覆盖结构、告警与异常路径；`test_nl_query_missing_text_422` 验证请求体验证与统一错误结构
- ♻️ 依赖对齐：`requirements.txt` 增加 `httpx`（用于 TestClient 运行时依赖）
- ▶️ 后续：完善端到端测试与容器化文档对齐
**2025-11-12T00:08:50+08:00 (Asia/Shanghai)**
- ✅ 方案确认：优先补齐 UI 图表展示；FastAPI 端点后续补全
- ♻️ 文档对齐：统一环境变量为 `DASHSCOPE_API_KEY` / `DEFAULT_MODEL`；`docker-compose.yml` 使用 `DASHSCOPE_API_KEY`
- 🧪 测试计划：图表完成后进行端到端测试；现有数据库/文件数据作为测试数据使用
- 🔌 集成计划：Redis 接入阶段性任务已加入开发计划（当前阶段不开发）

**2025-11-11T18:07:08+08:00 (Asia/Shanghai)**
- ✅ 新增 LLM 代理模块：`orchestrator/llm_proxy.py`，固化 `FILTER_PARAMS_JSON_SCHEMA`，复用 Router 参数校验，支持降级解析与指标记录
- ✅ 新增自然语言查询入口：`orchestrator/__init__.py` 暴露 `nl_query(text, default_filters=None, systems=None, timeout_ms=...)`，桥接至 `query_across_systems`
- ✅ 新增集成测试：`tests/integration/test_nl_query_llm_proxy.py`（覆盖 LLM 正常解析、降级、显式 systems 覆盖、非法 entity_type 清洗）
- ✅ 新增 Streamlit UI 页面（方案B）：`ui/nl_query.py`，输入自然语言并展示聚合结果与 `metrics.llm`
- ♻️ 复用：严格复用 Router 与 Executor 的校验与聚合逻辑，无重复实现
- 📈 指标：在返回 `metrics.llm` 记录 `llm_used/llm_status/llm_latency_ms/llm_model`，与编排层指标合并
- 📚 说明：详细断言与路径见测试文件；图表展示后续补充；FastAPI 端点（方案A）拟在下一阶段加入
- ▶️ 下一步：补充方案A（FastAPI 端点 /nl-query）与图表展示

**2025-11-10T17:00:29+08:00 (Asia/Shanghai)**
- ✅ 完成编排层高层入口：`orchestrator/__init__.py` 暴露 `query_across_systems(filter_params, systems=None, timeout_ms=...)`
- ✅ 完成执行器模块：`orchestrator/executor.py`（并发执行、聚合、错误降级、指标统计），复用 `BaseAgent.query_canonical` 与缓存
- ✅ 完成路由器模块：`orchestrator/router.py`（系统选择与参数校验）
- ✅ 新增并完善编排层集成测试：`tests/integration/test_orchestrator_router_executor.py`（路由子集、部分失败、超时、过滤透传、去重）
- ♻️ 复用：严格复用现有 Agent 方法与 Canonical 模型，无重复开发
- 📈 指标：记录每系统执行时长与结果计数、成功/失败统计、总时长
- 📚 说明：详细断言与场景请参见测试文件；按需继续补充性能与LLM集成测试

**2025-11-07 23:30:37**
- ✅ 新增并通过集成测试：`tests/integration/test_canonical_consistency.py`、`tests/integration/test_filters_and_cache.py`、`tests/integration/test_error_handling_and_consistency.py`
- ♻️ 复用：`BaseAgent.query_canonical/clear_cache/get_cache_info` 与 `DataMapper` 方法，无重复开发
- 🔧 修订：HR 交易金额断言调整为 `>= 0`，ERP/FIN 保持 `> 0`
- 🧩 一致性：ID 命名空间统一（`erp_/hr_/fin_`），FIN 在缺失组织时采用回退前缀保障一致性
- 📈 缓存：重复调用命中率提升、参数变化触发未命中，命中率指标可通过 `get_cache_info()` 获取
- 📚 说明：详细断言与测试运行说明，请参考各测试文件头部注释
- ✅ 完成 FINAgent 开发与映射（`agents/fin.py`）
- ✅ 新增测试 `tests/test_fin_agent.py` 并通过
- 🔧 修复：交易 `currency` 统一设为 `CNY`，满足 Canonical 校验
- ♻️ 复用：沿用 `BaseAgent` 与 `DataMapper`，避免重复开发
- 🗂 架构说明修订：FIN 数据源为 SQLite（`ucap_demo.db` 的 `fin_*` 表），与 ERP/HR 一致
- 📚 技术要点：
  - 统一 `_entity` 标签，集中索引支持跨表关联（`org_code_to_id`）
  - `amount` 使用 `normalize_amount` 转 `Decimal`（两位小数）
  - 日期统一 `normalize_date('fin')`；`created_at` 采用回退链路
  - 组织/人员/客户/交易字段映射与 Pydantic v2 校验一致

**2025-11-03 12:18:13**
- ✅ 完成Pydantic v2兼容性修复
- ✅ 修复所有测试用例的字段名映射问题
- ✅ 优化DataMapper.normalize_amount方法的错误处理
- ✅ 所有19个核心测试全部通过
- 📚 **技术要点**：
  - Pydantic v2字段名必须与模型定义严格一致
  - 测试数据中的`canonical_id`需要根据不同模型使用对应字段名
  - `system_type` → `source_system`，`created_time` → `created_at`
  - DataMapper方法需要正确处理无效输入并抛出适当异常

**2025-10-31 **
- ✅ 完成项目基础框架搭建
- ✅ 实现三个系统的数据生成器 (ERP/HR/FIN)
- ✅ 完成Pydantic数据模型定义
- ✅ 实现DataMapper数据转换工具
- ✅ 编写完整的单元测试套件
## 12. 时间过滤语义与示例

- 过滤语义
  - persons：按业务字段 `hire_date` 过滤；缺失时回退 `created_at`
  - transactions：按业务字段 `tx_date` 过滤；缺失时回退 `created_at`
  - organizations / customers：按 `created_at` 过滤
  - 时间字符串解析使用 `dateutil.parser.isoparse`，兼容 ISO8601（支持 `Z` 后缀）

- 参数透传
  - `Router` 对 `date_from`/`date_to` 仅做类型与格式校验，不转换为 `datetime`；具体解析在 Agent 层完成
  - `Executor` 透传过滤参数至各 Agent，无额外处理

- 自然语言降级解析（LLM时间缺失时仅补齐，不覆盖其它字段）
  - 识别中文相对时间表达：`近/最近/过去 + 数字/中文数词(含“两”) + 年/月/天/周/星期`，支持可选“个”（如“近3个月”“近1个星期”）
  - 解析为区间：`date_to = today`，`date_from = today - relativedelta(...)`
  - 模块位置：`orchestrator/llm_proxy.py::_fallback_parse`（本次修复扩展正则以支持“两/个”表达）

- 日志验证与结果
  - Orchestrator INFO：`nl_query()` 打印最终 `filter_params`、`systems`、`timeout_ms`
  - Base DEBUG：`_apply_filters()` 打印生效的时间字段 (`hire_date`/`tx_date`/`created_at`) 与区间 (`date_from`/`date_to`)
  - 当前版本日志已返回预期内容，相关查询测试成功

## 13. 启动项目
启动后端： uvicorn api.main:app --reload --host 127.0.0.1 --port 8000
- 接口前缀：使用 /api （如 http://127.0.0.1:8000/api/nl-query ）

**文档版本**: v1.6  
**最后更新**: 2025-11-13T00:50:03+08:00 (Asia/Shanghai)
 

